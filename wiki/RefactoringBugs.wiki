Here is a list of bugs we found in the refactoring engines of Eclipse and other popular Java IDEs. All test cases were evaluated on Eclipse 3.3.1, JBuilder 2007, !NetBeans 6.0, IntelliJ 8.0, and JDeveloper 11g.

<h2>Bug in Rename Package</h2>
<ol>
<li> <b>No Check for Name Clash with Class</b>:

  Test case:
  {{{
    package p;
    class r { }
    ...
    package p.q; 
    class s { }
  }}}

  Eclipse allows renaming package `p.q` to `p.r`, 
  resulting in uncompilable code due to name clash with class 
  `p.r`. When undoing the refactoring, the error marker is
  not removed; it vanishes only after further editing and saving the files
  involved.

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=208200">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, !NetBeans, <a href="http://www.jetbrains.net/jira/browse/IDEA-20574">IntelliJ</a> (since fixed), and JDeveloper.



<h2>Bugs in Rename Type</h2>
<ol>
<li> <b>Renaming Top Level Type Leads to Undiagnosed Shadowing of Library Type</b>:

  Test case:
  {{{
  public class A {
    public static void main(String[] args) {
      new Thread() {
        public void run() {
          System.out.println(23);
	}
      }.start();
    }
  }

  class MyThread {
    public void start() {
      System.out.println(42);
    }
  }
  }}}

  Renaming `MyThread` to `Thread` shadows the library class `java.lang.Thread`, which
  is not noticed by Eclipse. Thus the program changes from printing `23` before refactoring to printing
  `42` after.

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=222848">Eclipse Bugs</a>, turned out to be a duplicate.

  The same bug also occurs in JBuilder, !NetBeans, <a href="http://www.jetbrains.net/jira/browse/IDEA-20603">IntelliJ</a>, and JDeveloper.

<li> <b>Renaming Member Type in Superclass Leads to Undiagnosed Shadowing</b>:

  Test case:
  {{{
    class A {
      static class B {
        static int x = 42;
      }
    }
	  
    public class D {
      static class C extends A {
        static int x = 23;
	static int m() { return C.x; }
      }
      public static void main(String[] args) {
	System.out.println(C.m());
      }
    }
  }}}
	  
  This prints `23`. Renaming the class `B` inside 
  `A` to `C` does not notice that the
  reference `C.x` in method `C.m` will now refer to 
  `A.C.x` instead of `D.C.x`, so the resulting
  program prints `42`.

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=220781">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, !NetBeans, <a href="http://www.jetbrains.net/jira/browse/IDEA-20634">IntelliJ</a> (since fixed), and JDeveloper.

<li><b>Renaming a Member Type Does Not Check for Shadowing of Inherited Member Types</b>:

  Test case:
  {{{
  import java.util.Map;

  abstract class MyMap implements Map {
    abstract static class MyEntry implements Entry {
    }
  }
  }}}

  Renaming the member class `MyEntry` to `Entry`
  does not notice that this shadows the member type `Map.Entry`.
  The resulting program is

  {{{
  import java.util.Map;

  abstract class MyMap implements Map {
    abstract static class Entry implements Entry {
    }
  }
  }}}

  which does not compile. It is possible to construct examples where the
  resulting code would still compile, but have a different behaviour.

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=222045">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, !NetBeans, JDeveloper, but not in IntelliJ.


<li><b>Renaming a Type Does Not Check for Capture by Type Variable</b>:

  Test case:
  {{{
  public class A {
    public static void main(String[] args) {
      C&lt;A&gt; b = new D&lt;String&gt;();
    }
  }
  class C&lt;T&gt; { }
  class D&lt;B&gt; extends C&lt;A&gt; { }
  }}}












  Renaming class `A` to `B` yields the following output:
  {{{
  public class B {
    public static void main(String[] args) {
      C&lt;B&gt; b = new D&lt;String&gt;();
    }
  }
  class C&lt;T&gt; { }
  class D&lt;B&gt; extends C&lt;B&gt; { }
  }}}

  Note the capture of the argument type `A` by the type variable
  `B`:
  The program is not compilable, since `D&lt;String&gt;()` can no
  longer be cast to `D&lt;A&gt;`, but only to `D&lt;String&gt;`.

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=220780">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, !NetBeans, JDeveloper, but not in IntelliJ.


	

<h2>Bug in Rename Variable</h2>
<ol>
<li><b>Renaming Field Can Shadow Static Import</b>:

  Test case:
  {{{
  import static java.lang.Math.PI;

  class Indiana {
    static double myPI = 3.2;
    static double circle_area(double r) {
      return PI*r*r;
    }
  }
  }}}

  Renaming the field `myPI` to `PI` shadows the import from `java.lang.Math`.
  This problem is correctly diagnosed by Eclipse and JBuilder, but not by !NetBeans and JDeveloper. A
  <a href="http://www.jetbrains.net/jira/browse/IDEA-20665">slightly more complex example</a> fools IntelliJ.

<li><b>Renaming Local Variable Can Lead to Shadowing By Field</b>:

  Test case:
  {{{
  public class A {
    Object m() {
      final int i = 23;
      return new Object() {
        int j = 42;
        public String toString() {
          return i+"";
        }
      };
    }
    public static void main(String[] args) {
      System.out.println(new A().m());
    }
  }
  }}}

  This prints `23`. Renaming the local variable `i` in 
  method `A.m` to `j` does not notice that the reference 
  in the `toString()` method of the anonymous class will now
  refer to the field `j`, so the resulting program prints 
  `42`.
	
  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=213144">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, <a href="http://www.jetbrains.net/jira/browse/IDEA-20700">IntelliJ</a> (fixed), and JDeveloper, 
  but not in !NetBeans. If we instead try to
  rename `j` to `i`, Eclipse and JBuilder both report the danger of shadowing, whereas
  !NetBeans and IntelliJ do not. JDeveloper does not implement this second renaming.

	

<h2>Bug in Rename Method</h2>
<ol>
<li><b>Renaming Method Can Lead to Shadowing of Statically Imported Method</b>:

  Test case:
  {{{
    import static java.lang.String.*;

    public class A {
      static String m(int i) { return "42"; }
      public static void main(String[] args) {
        System.out.println(valueOf(23));
      }
    }
  }}}
	  
  This prints `23`. Renaming the method `A.m` to 
  `valueOf` shadows the statically imported method 
  `String.valueOf`, so the resulting program prints `42`.

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=220779">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, !NetBeans, and JDeveloper, but not in IntelliJ.



<h2>Bugs in Encapsulate Field</h2>
<ol>
<li> <b>Should Not Allow Encapsulating Fields in Interfaces</b>:

   Test case:
   {{{
     interface A {
       int f = 23;
     }
   }}}

   Encapsulating field `A.f` should fail, since it is in an interface and hence no getter method can be
   created. This is, however, not detected, resulting in uncompilable code.

   This bug was reported by someone else <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=34310">quite some time ago</a>,
   but judged "not critical".

   The same bug also occurs in JBuilder and JDeveloper, but not in !NetBeans and IntelliJ.

<li> <b>No Check for Method Hiding</b>:

   Test case:
   {{{
     class A {
       void getI(String s) { }

       class C { class B { void m() { getI(""); } } private int i; }
     }
   }}}

   When encapsulating field `C.i`, Eclipse generates a getter method
   `getI()` in class C which shadows the access in 
   method `C.B.m()` and leads to uncompilable code.


  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=209315">Eclipse Bugs</a>, turned out to be a duplicate.

  The same bug also occurs in JBuilder, !NetBeans, <a href="http://www.jetbrains.net/jira/browse/IDEA-20720">IntelliJ</a>, and JDeveloper.

<li> <b>No Check for Overloading Problems</b>:

   Test case:
   {{{
     class A {
       public int i;
     }
     class B extends A {
       public int getI() { return 42; }
       public static void main(String[] args) {
         A a = new B();
	 a.i = 23; 
	 System.out.println("i == "+a.i);
       }
     }
   }}}

   This code prints `i == 23`, as it should. Now we can encapsulate 
   field `A.i`, yielding the following code:

   {{{
     class A {
       private int i;
       public void setI(int i) { this.i = i; }
       public int getI() { return i; }
     }

     class B extends A {
       public int getI() { return 42; }
       public static void main(String[] args) {
         A a = new B();
	 a.setI(23);
	 System.out.println("i == "+a.getI());
     }
   }}}

   This code compiles and prints `i == 42`.

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=209316">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, !NetBeans, <a href="http://www.jetbrains.net/jira/browse/IDEA-20745">IntelliJ</a>, and JDeveloper.

<li><b>No Check for Invalid Overloading</b>:

   Test case:
   {{{
     class A {
       public int i;
     }
     class B extends A {
       private int getI() { return 42; }
     }
   }}}

   Encapsulating field `A.i` generates a public getter method 
   `A.getI()` which cannot be overloaded by `B.getI()`, 
   resulting in a compiler error. The
   same kind of problem occurs if, say, `B.getI()` were
   declared as having return type "float".

  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=209317">Eclipse Bugs</a>, turned out to be a duplicate.

  The same bug also occurs in JBuilder, !NetBeans, IntelliJ, and JDeveloper.



<h2>Bugs in Extract Method</h2>
<ol>
<li> Applying the Extract Method refactoring to the following selection results in 
  a new method that fails to compile.

  Original program:
  {{{
  private int f(boolean b1, boolean b2) {
    int n = 0;
    int i = 0;
    // Extract Method from here
    if (b1)
      i = 1;
    if (b2)
      n = n + i;
    // to here
    return n;
  }
  }}}
  Applying Extract Method on the selected code (signalled by the comments)
  results with the following code: 
  {{{
  private int f(boolean b1, boolean b2) {
    int n = 0;
    int i = 0;
    n = newMethod(b1, b2, n);
    return n;
  }

  private int newMethod(boolean b1, boolean b2, int n) {
    int i;
    if (b1)
      i = 1;
    if (b2)
      n = n + i;
    return n;
  }
  }}}
  Problem: Eclipse did not identify that the local variable i should be sent as 
  a parameter. The program doesn't compile anymore, because in the statement `n = 
  n + i`; in the new method, "the local variable `i` may not have been initialized".

  Instead, the refactored source should look like this:
  {{{
  private int f(boolean b1, boolean b2) {
    int n = 0;
    int i = 0;
    n = newMethod(b1, b2, n, i);
    return n;
  }

  private int newMethod(boolean b1, boolean b2, int n, int i) {
    if (b1)
      i = 1;
    if (b2)
      n = n + i;
    return n;
  }
  }}}

  Track this bug at <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=109280">Eclipse Bugs</a>.
  <b>Note</b>: This bug was fixed in Eclipse 3.2 RC1. It does not occur in JBuilder, !NetBeans, IntelliJ, and JDeveloper.
<li>Trying to apply the Extract Method refactoring on the following selection 
  results in an unnecessary rejection.

  Original program: 
  {{{
  private int g(boolean b) {
    int n = 10;
    int i = 0;
    while (i < n) {
      if (b) {
        // Extract Method from here
        i++;
        n -= i;
	// to here
        break;
      }
      else i++;
    }
    return n;
  }
  }}}

  Applying Extract Method on the selected code (signalled by the comments)
  results in a rejection with the message: "Ambiguous return value: selected 
  block contains more than one assignment to local variable".

  In fact, because of the `break` statement, only the modified local variable `n` 
  should be returned. The local variable `i` will never be relevant on return from 
  the extracted method. As a result, variable `i` can be localized in the new 
  method.

  The refactored source should look like this:
  {{{
  private int g(boolean b) {
    int n = 10;
    int i = 0;
    while (i < n) {
      if (b) {
        n = newMethod(i, n);
        break;
      }
      else i++;
    }
    return n;
  }

  private int newMethod(int i, int n) {
    i++;
    n -= i;
    return n;
  }
  }}}
  Track this bug at <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=109282">Eclipse Bugs</a>.

  The same bug also occurs in JBuilder, !NetBeans, and JDeveloper, but not in IntelliJ.

<li><b>Liveness Analysis in Extract Method Is Not Precise Enough</b>:

    Test case:
    {{{
    public class A {
      void m() {
        int y;
        int z;
        //from
	try {
	  if(3==3)
	    y = 1;
	  else
	    throw new Exception("boo");
	} catch(Throwable t) {
	  y=2;
	}
	z=y;
        //to
      }
    }
    }}}
	  
    If we extract the statements between `//from` and 
    `//to` into a method, Eclipse infers the local variable 
    `y` to be live and passes it as a parameter to the
    newly created method. In fact, however, `y` is not live, 
    so the resulting code does not compile due to a violation of the 
    definite assignment restriction.

    Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=220777">Eclipse Bugs</a>.

    The same bug also occurs in JBuilder and !NetBeans, but not in IntelliJ and JDeveloper.

<li><b>Local types are not handled correctly</b>:

    Test case:
    {{{
    public class A {
      void m() {
        // from
        class X { }
        X x;
        // to
        x = null;
      }
    }
    }}}

    If we extract the statements between `//from` and 
    `//to` into a method `n` in Eclipse, we get

    {{{
    public class A {
      void m() {
        X x;
        n();
        x = null;
      }

      void n() {
        class X { }
        X x;
      }
    }
    }}}

    which fails to compile.

    The same bug occurs in <a href="http://www.jetbrains.net/jira/browse/IDEA-20769">IntelliJ</a>.
<li> <b>Incorrect dataflow analysis</b>:

  Test case:
  {{{
  public class A {
    void m(boolean b) {
      int x = 42;
      try {
        // from
        if(b) {
          x = 23;
          throw new Exception();
        }
        // to
      } catch(Exception e) {
        System.out.println(x);
      }
    }

    public static void main(String[] args) {
        new A().m(true);
    }
  }
  }}}

  This program prints `23`. Extracting the statement between the comments to a method `n` in Eclipse yields

  {{{
  public class A {
    void m(boolean b) {
      int x = 42;
      try {
        x = n(b, x);
      } catch(Exception e) {
        System.out.println(x);
      }
    }

    private int n(boolean b, int x) throws Exception {
      if(b) {
	x = 23;
	throw new Exception();
      }
      return x;
    }

    public static void main(String[] args) {
        new A().m(true);
    }
  }
  }}}

  Eclipse has `n` return the value of `x`, which is unnecessary, but not our main concern. More importantly, note that the
  value printed in the `catch` clause is the unmodified value of `x`, hence the refactored program prints `42`.

  The same bug occurs in <a href="http://www.jetbrains.net/jira/browse/IDEA-21120">IntelliJ</a>, although it correctly diagnoses that the value of `x` does not need to be returned. The bug is fixed in the newest release.


<h2>Bugs in Inline Local Variable</h2>
<ol>
<li> <b>Incorrect handling of references to final variables</b>:

  Test case:
  {{{
  class A {
    void m() {
      int j = 23;
      final int i = j;
      new Object() {
	{ System.out.println(i); }
      };
    }
  }
  }}}

  Inlining variable `i` replaces the initializer of the anonymous class
  with
  {{{
        { System.out.println(j); }
  }}}

  which fails to compile, since `j` is not final and hence inaccessible
  from inside the anonymous class.

  The same bug occurs in <a href="http://www.jetbrains.net/jira/browse/IDEA-20790">IntelliJ</a>.



<h2>Bugs in Push Down Method</h2>
Note: None of these example refactorings could be tested in JDeveloper.
<ol> 
<li> <b>Incorrect handling of `super` accesses</b>:
   
   Test case:
   {{{
     class A {
       void k() { System.out.println(23); }
     }
     class B extends A {
       void m() { super.k(); }
       void k() { System.out.println(42); } 
     }
     class C extends B {
       public static void main(String[] args) {
         new C().m();
       }
     }
   }}}
   	 
   This prints `23`. Pushing down `B.m` into 
   `C` just moves the method without any
   adjustments, so the resulting program prints `42`.
   
  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=211755">Eclipse Bugs</a>.

  The same bug occurs in JBuilder, !NetBeans, and <a href="http://www.jetbrains.net/jira/browse/IDEA-20816">IntelliJ</a> (fixed).

<li> <b>Incorrect handling of field accesses</b>:   

   Test case:
   {{{
     class A {
       protected int x = 23;
       void m() { System.out.println(x); }
     }
     class B extends A {
       protected int x = 42;
       public static void main(String[] args) {
         new B().m();
       }
     }
   }}}
     
   This prints `23`. Pushing down `A.m` into 
   `B` just moves the method without any

   adjustments, so the resulting program prints `42`.
   

   Reported as a comment to the previous bug.

   The same bug occurs in JBuilder, !NetBeans, and <a href="http://www.jetbrains.net/jira/browse/IDEA-20848">IntelliJ</a>.
<li> <b>Incorrect Handling of Type Accesses</b>:
   
   Test case:
   {{{
     class A {
       class B { public B() { System.out.println(23); } }
       B m() { return new B(); }
     }
     class C extends A {
       class B { public B() { System.out.println(42); } }
       public static void main(String[] args) {
         new C().m();
       }
     }
   }}}
     
   This prints `23`. Pushing down `A.m` into 
   `B` just moves the method without any
   adjustments, so the resulting program prints `42`. 
   A similar issue exists with `throws` clauses.
   
  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=211859">Eclipse Bugs</a>.

  The same bug occurs in JBuilder and !NetBeans, but not in IntelliJ.

<li><b>Incorrect Handling of Private Method Accesses</b>:

   Test case:
   {{{
     class A {
       private void k() { System.out.println(23); }
       void m() { k(); }
     }
     class B extends A {
       protected void k() { System.out.println(42); }
       public static void main(String[] args) {
         new B().m();
       }
     }
   }}}
     
   This prints `23`. Pushing down `A.m` into 
   `B` just moves the method without any
   adjustments, so the resulting program prints `42`.
   
  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=211860">Eclipse Bugs</a>.

  The same bug occurs in JBuilder, !NetBeans, and <a href="http://www.jetbrains.net/jira/browse/IDEA-20873">IntelliJ</a>.


<li><b>No Check for References to Moved Method</b>:
   
   Test case:
   {{{
     class A {
       void m() { }
     }
     class B extends A {
       public static void main(String[] args) {
         new A().m();
       }
     }
   }}}
   
   Pushing down `A.m` into `B` does not detect the 
   reference to `A.m` in `B.main`, so
   the resulting program fails to compile.
   
  Reported to <a href="http://bugs.eclipse.org/bugs/show_bug.cgi?id=211861">Eclipse Bugs</a>, turned out to be a duplicate.

  The same bug also occurs in JBuilder and !NetBeans, but not in IntelliJ.

